% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/autofpf.R
\name{auto.fpf}
\alias{auto.fpf}
\title{Automated full pattern fitting}
\usage{
auto.fpf(smpl, lib, tth, std, amorphous, coarse = 0.1, align = 0.1,
  solver = "BFGS", obj = "Rwp", shift = 0.05, weighting)
}
\arguments{
\item{smpl}{A data frame. First column is 2theta, second column is counts}

\item{lib}{The XRPD library. A list containing three elements. The first (\code{XRPD}) is a dataframe
containing all pre-measured reference patterns by column. The second (\code{TTH}) is a vector of the
2theta measurement intervals for the reference patterns. Third (\code{MINERALS}) is a data frame
containing the unique ID, mineral name, and reference intensity ratio of each pattern in the library.
The order of \code{XRPD} (by column) and \code{MINERALS} (by row) must be identical.}

\item{tth}{A vector defining the minimum and maximum 2theta values to be used during
fitting}

\item{std}{The mineral ID (e.g. "Qzt.662070.Strath.12Mins.P") to be used as internal standard. Must match a mineral
name in the MINERALS table.}

\item{amorphous}{Optional. Then name of an amorphous phase to be added to the fitting process. Must
match an ID in the MINERALS table.}

\item{coarse}{The tuning parameter used to adjust coarseness of fit. Must be greater than 0 and
less than 100. Low values are more sensitive to minor phases. Default = 0.1.}

\item{align}{The maximum shift that is allowed during initial 2theta alignment (degrees). Default = 0.1.}

\item{solver}{The optimisation routine to be used. One of \code{c("BFGS", "Nelder-Mead", "CG")}. Default = \code{"BFGS"}.}

\item{obj}{The objective function to minimise. One of \code{c("Delta", "R", "Rwp")}. Default = \code{"Rwp"}.}

\item{shift}{Optional. The maximum shift applied during full pattern fitting. Default = 0.05.}

\item{weighting}{Optional. A two column dataframe. First column contains 2theta axis on same scale as that
of the XRD library. Second column contains the weighting of each 2theta variable. If not provided, all
variables are given a weighting of 1.}

\item{phases}{A string of unique ID's from the \code{lib} used to subset the reference library.}
}
\value{
a list with components:
\item{TTH}{A vector of the 2theta scale of the fitted data}
\item{FITTED}{A vector of the fitted XRPD pattern}
\item{MEASURED}{A vector of the original XRPD measurement}
\item{RESIDUALS}{A vector of the Residuals of FITTED vs MEASURED}
\item{MINERALS}{A dataframe of the minerals used to produced FITTED}
\item{MINERALS_SUMMARY}{The MINERALS dataframe grouped by minerals and summarised (mean)}
\item{R}{The Rwp of the FITTED vs MEASURED pattern}
\item{WEIGHTED_PURE_PATTERNS}{A dataframe of reference patterns used to produce FITTED.
All patterns have been weighted according to the coefficients used in the fit}
\item{COEFFICIENTS}{A named vector of coefficients used to produce FITTED}
}
\description{
\code{auto.fpf} returns estimates of soil mineral concentraitons using full pattern
 fitting. This automated version attempts to extract the most appropriate phases
 from the library.
}
\details{
This function applies full pattern fitting to an XRPD sample to quantify mineral concentrations.
It requires a library of reference patterns with pre-measured reference intensity ratios.
}
\examples{
# Load the Xpert library
data(Xpert)

# Load the Xpert soil data to use in example
data(Xpert_soil)
# automated without any amorphous phases
# not run
# fpf_out <- auto.fpf(smpl = Xpert_soil$mineral,
#                    lib = Xpert,
#                    tth = c(3.5, 69.5),
#                    std = "Qzt.662070.Strath.12Mins.P")

#automated with an amorphous phase (organic matter)
#not run
#fpf_out_org <- auto.fpf(smpl = Xpert_soil$mineral,
#                    lib = Xpert,
#                    tth = c(3.5, 69.5),
#                    std = "Qzt.662070.Strath.12Mins.P",
#                    amorphous = "ORGANIC.337666")

# An example of using weighting
weighting <- data.frame(TTH = Xpert$TTH,
                        COUNTS = rep(1, length(Xpert$TTH)))

# Make all values below TTH = 5 have a weighting of 0
weighting$COUNTS[which(weighting$TTH <= 5)] <- 0

# Make all values between TTH = 26 and 27 have a weighting of 2
weighting$COUNTS[which(weighting$TTH >= 26 & weighting$TTH <= 27)] <- 10
}
