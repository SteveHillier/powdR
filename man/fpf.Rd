% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fpf.R
\name{fpf}
\alias{fpf}
\title{Full pattern fitting}
\usage{
fpf(smpl, lib, crystalline, std, amorphous, tth, align, solver, obj, shift,
  weighting)
}
\arguments{
\item{smpl}{A data frame. First column is 2theta, second column is counts}

\item{lib}{The XRPD library. A list containing three elements. The first (\code{XRPD})
is a dataframe containing all pre-measured reference patterns by column. The second
(\code{tth}) is a vector of the 2theta measurement intervals for the reference patterns.
Third (\code{minerals}) is a data frame containing the unique ID, mineral name, and
reference intensity ratio of each pattern in the library. The order of \code{XRPD}
(by column) and \code{minerals} (by row) must be identical.}

\item{crystalline}{A string of mineral ID's used to subset crystalline phases from the
library. The ID's must match ID's in the \code{lib$minerals$MIND_ID} column.}

\item{std}{The mineral ID (e.g. "Qzt.662070.Strath.12Mins.P") to be used as internal
standard. Must match an ID provided in the \code{phases} parameter.}

\item{amorphous}{Optional. The ID's of amorphous phases (e.g. "ORGANIC.337666") to be
added to the fitting process.}

\item{tth}{A vector defining the minimum and maximum 2theta values to be used during
fitting.}

\item{align}{The maximum shift that is allowed during initial 2theta alignment (degrees).
Default = 0.1.}

\item{solver}{The optimisation routine to be used. One of \code{c("BFGS", "Nelder-Mead",
"CG")}. Default = "BFGS".}

\item{obj}{The objective function to minimise. One of \code{c("Delta", "R", "Rwp")}.
Default = \code{"Rwp"}.}

\item{shift}{Optional. The maximum shift applied during full pattern fitting.
Default = 0.05}

\item{weighting}{Optional. A two column dataframe. First column contains 2theta axis on
same scale as that of the xrd library. Second column contains the weighting of each 2theta
variable. If not provided, all variables are given a weighting of 1.}
}
\value{
a list with components:
\item{tth}{a vector of the 2theta scale of the fitted data}
\item{fitted}{a vector of the fitted XRPD pattern}
\item{measured}{a vector of the original XRPD measurement}
\item{residuals}{a vector of the Residuals of fitted vs measured}
\item{minerals}{a dataframe of the minerals used to produce the fitted pattern}
\item{minerals_summary}{the minerals dataframe grouped by minerals and summarised (mean)}
\item{rwp}{the Rwp of the fitted vs mesaured pattern}
\item{weighted_pure_patterns}{a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit}
\item{coefficients}{a named vector of coefficients used to produce the fitted pattern}
}
\description{
\code{fpf} returns estimates of soil mineral concentraitons using full pattern fitting.
}
\details{
This function applies full pattern fitting to an XRPD sample to quantify mineral
concentrations.
It requires a library of reference patterns with pre-measured reference intensity ratios.
}
\examples{
#Load the minerals library
data(minerals)

# Load the soils data
data(soils)

# define the phases to include in the fit
c_phases <- c("FEL.10.P.969175", "KAO.76.P.791169",
"OLIG.5.P.969178", "QUA.10.P.1002643", "QUARTZ.STRATH.P.1142250")

# without organic
\dontrun{
fpf_out <-  fpf(smpl = soils$sandstone,
               lib = minerals,
               tth = c(4.5, 69.5),
               crystalline = c_phases,
               std = "QUARTZ.STRATH.P.1142250")
}

# Try fitting the same sample, but including an amorphous phase (organic matter)
\dontrun{
fpf_out_org <-  fpf(smpl = soils$sandstone,
                   lib = minerals,
                   tth = c(4.5, 69.5),
                   crystalline = c_phases,
                   std = "QUARTZ.STRATH.P.1142250",
                   amorphous = "ORGANIC.bez.CRAIGLICHT.668085.DEEP")
}

# An example of using weighting
weighting <- data.frame(tth = minerals$tth,
                        counts = rep(1, length(minerals$tth)))

# Make all values below tth = 5 have a weighting of 0
weighting$counts[which(weighting$tth <= 5)] <- 0

# Make all values between tth = 26 and 27 have a weighting of 2
weighting$counts[which(weighting$tth >= 26 & weighting$tth <= 27)] <- 10
}
